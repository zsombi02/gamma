/********************************************************************************
 * Copyright (c) 2018 Contributors to the Gamma project
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * SPDX-License-Identifier: EPL-1.0
 ********************************************************************************/
package hu.bme.mit.gamma.derived
/*
import "http://www.mit.bme.hu/gamma/statechart/Model"
import "http://www.mit.bme.hu/gamma/statechart/Model/Interface"
import "http://www.mit.bme.hu/gamma/statechart/Model/Composite"

@QueryBasedFeature(feature = "isBroadcast")
pattern isBroadcast(interfaceRealization : InterfaceRealization, isBroadcast: java Boolean) {
	InterfaceRealization.realizationMode(interfaceRealization, ::PROVIDED);
	InterfaceRealization.interface(interfaceRealization, interface);
	EVENT_COUNT == count find events(interface, _);
	OUT_EVENT_COUNT == count find outEvents(interface, _);
	isBroadcast == eval (EVENT_COUNT == OUT_EVENT_COUNT);
} or {
	InterfaceRealization.realizationMode(interfaceRealization, ::REQUIRED);
	isBroadcast == false;
}

private pattern events(interface : Interface, event : EventDeclaration) {
	Interface.events(interface, event);
}

private pattern outEvents(interface : Interface, event : EventDeclaration) {
	find events(interface, event);
	EventDeclaration.direction(event, ::OUT);
}

@QueryBasedFeature(feature = "allPorts")
pattern allPorts(synchronousComponentWrapper : SynchronousComponentWrapper, port : Port) {
	SynchronousComponentWrapper.ports(synchronousComponentWrapper, port);
} or {
	SynchronousComponentWrapper.wrappedComponent.ports(synchronousComponentWrapper, port);
}

@QueryBasedFeature(feature = "eventSource")
pattern eventSource(eventReference : EventReference, eventSource : EventSource) {
	PortEventReference.port(eventReference, eventSource);
} or {
	AnyPortEventReference.port(eventReference, eventSource);
} or {
	ClockTickReference.clock(eventReference, eventSource);
} or {
	TimeoutEventReference.timeout(eventReference, eventSource);
}

@QueryBasedFeature(feature = "derivedType")
pattern derivedType(componentInstance : ComponentInstance, type : Component) {
	SynchronousComponentInstance.type(componentInstance, type);
} or {
	AsynchronousComponentInstance.type(componentInstance, type);
}

@QueryBasedFeature(feature = "derivedComponents")
pattern derivedComponents(compositeComponent : CompositeComponent, component : ComponentInstance) {
	AbstractSynchronousCompositeComponent.components(compositeComponent, component);
} or {
	AsynchronousCompositeComponent.components(compositeComponent, component);
}
*/